---
phase: 02-config-loader-and-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/types.ts
  - src/config/loader.ts
  - tests/config/loader.test.ts
autonomous: true
requirements: [CFG-01, CFG-02, CFG-03, CFG-04]

must_haves:
  truths:
    - "loadConfig('config.yaml') returns a validated AppConfig object with all 13 fields when the file is valid"
    - "DYNATRACE_API_TOKEN env var overrides the apiToken field from the config file"
    - "A config file with missing required fields (endpoint, namespaces) throws a descriptive validation error listing the invalid field"
    - "memoryHeadroomMultiplier below 1.30 in the config file is rejected with a clear error message"
    - "Optional fields (timeWindow, percentile, headroom multipliers, thresholds, outputPath) default to documented values when absent from config file"
  artifacts:
    - path: "src/config/types.ts"
      provides: "Zod schema (AppConfigSchema) and inferred TypeScript type (AppConfig)"
      exports: ["AppConfigSchema", "AppConfig"]
    - path: "src/config/loader.ts"
      provides: "loadConfig(filePath) function — reads YAML, validates with zod, applies env var override"
      exports: ["loadConfig"]
    - path: "tests/config/loader.test.ts"
      provides: "Vitest tests covering valid config, env var override, missing required field, and memoryHeadroomMultiplier floor"
      min_lines: 60
  key_links:
    - from: "src/config/loader.ts"
      to: "src/config/types.ts"
      via: "AppConfigSchema.parse()"
      pattern: "AppConfigSchema\\.parse"
    - from: "src/config/loader.ts"
      to: "DYNATRACE_API_TOKEN"
      via: "process.env.DYNATRACE_API_TOKEN override after parse"
      pattern: "process\\.env\\.DYNATRACE_API_TOKEN"
    - from: "tests/config/loader.test.ts"
      to: "src/config/loader.ts"
      via: "import { loadConfig } from"
      pattern: "import.*loadConfig.*from"
---

<objective>
Implement a config loader that reads config.yaml with js-yaml, validates the shape with zod, applies DYNATRACE_API_TOKEN env var override, and exposes a single loadConfig() function.

Purpose: Phase 3 needs a working loadConfig() to read endpoint and token before making any Dynatrace API call. This is the minimal plumbing that gates all downstream phases.
Output: src/config/types.ts (schema + type), src/config/loader.ts (loadConfig function), tests/config/loader.test.ts (vitest tests).
</objective>

<execution_context>
@/Users/shubh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shubh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@config.example.yaml
@.planning/phases/01-project-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define AppConfig zod schema and TypeScript type</name>
  <files>src/config/types.ts</files>
  <action>
Create src/config/types.ts. Define a zod schema called AppConfigSchema covering all 13 config fields from config.example.yaml. Use the following field specifications derived directly from config.example.yaml:

Required fields (no default):
- endpoint: z.string().url()
- apiToken: z.string().min(1)
- namespaces: z.array(z.string().min(1)).min(1)

Optional fields with defaults (use .default() in zod so parse() fills them in automatically):
- timeWindow: z.string().regex(/^\d+[dh]$/).default("7d")
- percentile: z.number().int().min(50).max(99).default(90)
- cpuHeadroomMultiplier: z.number().min(1.0).default(1.10)
- memoryHeadroomMultiplier: z.number().min(1.30).default(1.30)  — min(1.30) enforces the MEM-03 floor invariant
- cpuOverProvisionedThreshold: z.number().min(0.1).max(0.9).default(0.6)
- cpuUnderProvisionedThreshold: z.number().min(0.5).max(1.0).default(0.9)
- memoryOverProvisionedThreshold: z.number().min(0.1).max(0.9).default(0.6)
- memoryUnderProvisionedThreshold: z.number().min(0.5).max(1.0).default(0.9)
- minReplicaFloor: z.number().int().min(1).default(2)
- outputPath: z.string().min(1).default("./report.html")

Export AppConfigSchema and export type AppConfig = z.infer<typeof AppConfigSchema>.

IMPORTANT: This project uses ESM NodeNext. Do NOT use require(). Import zod as: import { z } from 'zod';
File must be valid TypeScript that passes tsc --noEmit.
  </action>
  <verify>
    <automated>cd /Users/shubh/Repos/Github_Shubham/ops-pod-optimization && npm run typecheck 2>&1 | tail -5</automated>
    <manual>src/config/types.ts exists and exports AppConfigSchema and AppConfig type</manual>
  </verify>
  <done>npm run typecheck exits 0 with src/config/types.ts present; AppConfigSchema and AppConfig are exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement loadConfig() function</name>
  <files>src/config/loader.ts</files>
  <action>
Create src/config/loader.ts. Implement and export a single function:

```typescript
export async function loadConfig(filePath: string): Promise<AppConfig>
```

Implementation steps in order:
1. Read the file at filePath using fs/promises readFile (encoding: 'utf-8'). Wrap in try/catch — if file not found, throw new Error(`Config file not found: ${filePath}`)
2. Parse the YAML string using js-yaml's load() function. Import as: import yaml from 'js-yaml';
3. Pass the parsed object to AppConfigSchema.parse(rawConfig). Let zod throw naturally on validation failure — do NOT catch zod errors; callers receive the ZodError with field-level messages.
4. After parse succeeds, check process.env.DYNATRACE_API_TOKEN. If it is a non-empty string, override config.apiToken with its value. (CFG-02: env var takes precedence over config file token.)
5. Return the final config object.

Imports needed:
- import { readFile } from 'node:fs/promises';
- import yaml from 'js-yaml';
- import { AppConfigSchema, type AppConfig } from './types.js';  (ESM .js extension required)

No commander wiring needed here — the --window override is a CLI concern wired in Phase 9 (CFG-03 full behavior). loadConfig() only handles file + env var.
  </action>
  <verify>
    <automated>cd /Users/shubh/Repos/Github_Shubham/ops-pod-optimization && npm run typecheck 2>&1 | tail -5</automated>
    <manual>src/config/loader.ts exists; loadConfig is exported as an async function</manual>
  </verify>
  <done>npm run typecheck exits 0 with both types.ts and loader.ts present and correctly typed</done>
</task>

<task type="auto">
  <name>Task 3: Write vitest tests for loadConfig()</name>
  <files>tests/config/loader.test.ts</files>
  <action>
Create tests/config/loader.test.ts. Use vitest (globals: true from vitest.config.ts — no need to import describe/it/expect).

Test setup: use node:fs/promises writeFile and mkdtemp (or a fixed temp path like /tmp/ops-pod-opt-test-config.yaml) to write YAML fixtures inline. Clean up in afterEach.

Write these four tests:

1. "loads a valid minimal config" — write a YAML file with only the three required fields (endpoint, apiToken, namespaces). Call loadConfig(). Assert:
   - config.endpoint equals the endpoint string
   - config.apiToken equals the token string
   - config.namespaces is an array with the given namespace
   - config.timeWindow equals "7d" (default applied)
   - config.percentile equals 90 (default applied)

2. "DYNATRACE_API_TOKEN env var overrides apiToken" — write a valid YAML with apiToken: "file-token". Set process.env.DYNATRACE_API_TOKEN = "env-token" before calling loadConfig(). Assert config.apiToken === "env-token". Restore env var in afterEach (delete process.env.DYNATRACE_API_TOKEN).

3. "throws on missing required field (endpoint)" — write a YAML with apiToken and namespaces but no endpoint. Assert that loadConfig() rejects (use await expect(...).rejects). The error message should be a ZodError — no specific string matching needed, just that it throws.

4. "throws on memoryHeadroomMultiplier below 1.30" — write a valid YAML with memoryHeadroomMultiplier: 1.10. Assert loadConfig() rejects.

Import: import { loadConfig } from '../src/config/loader.js';  (ESM .js extension, relative path from tests/ to src/)

Do NOT mock the filesystem — write real temp files. This keeps the test honest about actual YAML parsing.
  </action>
  <verify>
    <automated>cd /Users/shubh/Repos/Github_Shubham/ops-pod-optimization && npm test 2>&1 | tail -20</automated>
    <manual>All 4 tests in loader.test.ts pass; no skipped tests</manual>
  </verify>
  <done>npm test exits 0; loader.test.ts shows 4/4 tests passed</done>
</task>

</tasks>

<verification>
After all three tasks complete, run the full verification suite:

```bash
cd /Users/shubh/Repos/Github_Shubham/ops-pod-optimization
npm run typecheck && npm test
```

Expected: typecheck exits 0 (no TypeScript errors), npm test shows all tests passed including the 4 new loader tests.

Also verify file structure:
- src/config/types.ts exports AppConfigSchema and AppConfig
- src/config/loader.ts exports loadConfig
- tests/config/loader.test.ts has 4 tests
</verification>

<success_criteria>
1. `npm run typecheck` exits 0 — no TypeScript errors across the project
2. `npm test` exits 0 — all tests pass including loader.test.ts (4/4)
3. loadConfig() loads config.yaml, applies zod defaults, applies DYNATRACE_API_TOKEN override
4. Phase 3 can import loadConfig to get endpoint + token for the first live API call
</success_criteria>

<output>
After completion, create `.planning/phases/02-config-loader-and-auth/02-01-SUMMARY.md` following the summary template at @/Users/shubh/.claude/get-shit-done/templates/summary.md
</output>
